<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <base data-ice="baseUrl" href="../../../../../../../../">
  <title data-ice="title">Kaetram-Open/server/js/game/entity/character/combat/combat.js | kaetram</title>
  <link type="text/css" rel="stylesheet" href="css/style.css">
  <link type="text/css" rel="stylesheet" href="css/prettify-tomorrow.css">
  <script src="script/prettify/prettify.js"></script>
  <script src="script/manual.js"></script>
<meta name="description" content="Kaetram is an open-source game-engine created to aid those interested in entering the game development realm. The codebase is simple, clean, and intuitive, and is intended to be used as a learning tool. The original idea is based off Little Workshop&apos;s demo game - BrowserQuest. The assets have remained the same, but the code itself has been completely wiped and redone from the ground up."><meta property="twitter:card" content="summary"><meta property="twitter:title" content="kaetram"><meta property="twitter:description" content="Kaetram is an open-source game-engine created to aid those interested in entering the game development realm. The codebase is simple, clean, and intuitive, and is intended to be used as a learning tool. The original idea is based off Little Workshop&apos;s demo game - BrowserQuest. The assets have remained the same, but the code itself has been completely wiped and redone from the ground up."></head>
<body class="layout-container" data-ice="rootContainer">

<header>
  <a href="./">Home</a>
  
  <a href="identifiers.html">Reference</a>
  <a href="source.html">Source</a>
  
  <div class="search-box">
  <span>
    <img src="./image/search.png">
    <span class="search-input-edge"></span><input class="search-input"><span class="search-input-edge"></span>
  </span>
    <ul class="search-result"></ul>
  </div>
<a style="position:relative; top:3px;" href="https://github.com/Veradictus/Kaetram-Open"><img width="20px" src="./image/github.png"></a></header>

<nav class="navigation" data-ice="nav"><div>
  <ul>
    
  </ul>
</div>
</nav>

<div class="content" data-ice="content"><h1 data-ice="title">Kaetram-Open/server/js/game/entity/character/combat/combat.js</h1>
<pre class="source-code line-number raw-source-code"><code class="prettyprint linenums" data-ice="content">/* global module */

let _ = require(&apos;underscore&apos;),
    Hit = require(&apos;./hit&apos;),
    CombatQueue = require(&apos;./combatqueue&apos;),
    Utils = require(&apos;../../../../util/utils&apos;),
    Formulas = require(&apos;../../../../util/formulas&apos;),
    Modules = require(&apos;../../../../util/modules&apos;),
    Messages = require(&apos;../../../../network/messages&apos;),
    Packets = require(&apos;../../../../network/packets&apos;);

class Combat {
    constructor(character) {
        let self = this;

        self.character = character;
        self.world = null;

        self.attackers = {};

        self.retaliate = false;

        self.queue = new CombatQueue();

        self.attacking = false;

        self.attackLoop = null;
        self.followLoop = null;
        self.checkLoop = null;

        self.first = false;
        self.started = false;
        self.lastAction = -1;
        self.lastHit = -1;

        self.lastActionThreshold = 7000;

        self.cleanTimeout = null;

        self.character.onSubAoE((radius, hasTerror) =&gt; {
            self.dealAoE(radius, hasTerror);
        });

        self.character.onDamage((target, hitInfo) =&gt; {
            if (
                self.isPlayer() &amp;&amp;
                self.character.hasBreakableWeapon() &amp;&amp;
                Formulas.getWeaponBreak(self.character, target)
            )
                self.character.breakWeapon();

            if (hitInfo.type === Modules.Hits.Stun) {
                target.setStun(true);

                if (target.stunTimeout) clearTimeout(target.stunTimeout);

                target.stunTimeout = setTimeout(() =&gt; {
                    target.setStun(false);
                }, 3000);
            }
        });
    }

    begin(attacker) {
        let self = this;

        self.start();

        self.character.setTarget(attacker);
        self.addAttacker(attacker);

        attacker.combat.addAttacker(self.character); // For mobs attacking players..

        self.attack(attacker);
    }

    start() {
        let self = this;

        if (self.started) return;

        self.lastAction = new Date().getTime();

        self.attackLoop = setInterval(() =&gt; {
            self.parseAttack();
        }, self.character.attackRate);

        self.followLoop = setInterval(() =&gt; {
            self.parseFollow();
        }, 400);

        self.checkLoop = setInterval(() =&gt; {
            self.parseCheck();
        }, 1000);

        self.started = true;
    }

    stop() {
        let self = this;

        if (!self.started) return;

        clearInterval(self.attackLoop);
        clearInterval(self.followLoop);
        clearInterval(self.checkLoop);

        self.attackLoop = null;
        self.followLoop = null;
        self.checkLoop = null;

        self.started = false;
    }

    parseAttack() {
        let self = this;

        if (!self.world || !self.queue || self.character.stunned) return;

        if (self.character.hasTarget() &amp;&amp; self.inProximity()) {
            if (self.queue.hasQueue()) {
                self.hit(
                    self.character,
                    self.character.target,
                    self.queue.getHit()
                );
            }

            if (self.character.target &amp;&amp; !self.character.target.isDead())
                self.attack(self.character.target);

            self.sync();

            self.lastAction = self.getTime();
        } else self.queue.clear();
    }

    parseFollow() {
        let self = this;

        if (self.character.frozen || self.character.stunned) return;

        if (self.isMob()) {
            if (!self.character.isRanged()) self.sendFollow();

            if (self.isAttacked() || self.character.hasTarget())
                self.lastAction = self.getTime();

            if (self.onSameTile()) {
                let newPosition = self.getNewPosition();

                self.move(self.character, newPosition.x, newPosition.y);
            }

            if (self.character.hasTarget() &amp;&amp; !self.inProximity()) {
                let attacker = self.getClosestAttacker();

                if (attacker) self.follow(self.character, attacker);
            }
        }
    }

    parseCheck() {
        let self = this;

        if (self.getTime() - self.lastAction &gt; self.lastActionThreshold) {
            self.stop();

            self.forget();
        }
    }

    attack(target) {
        let self = this,
            hit;

        if (self.isPlayer()) hit = self.character.getHit(target);
        else {
            hit = new Hit(
                Modules.Hits.Damage,
                Formulas.getDamage(self.character, target)
            );
        }

        if (!hit) return;

        self.queue.add(hit);
    }

    sync() {
        let self = this;

        if (self.character.type !== &apos;mob&apos;) return;

        self.world.push(Packets.PushOpcode.Regions, {
            regionId: self.character.region,
            message: new Messages.Combat(Packets.CombatOpcode.Sync, {
                attackerId: self.character.instance, // irrelevant
                targetId: self.character.instance, // can be the same since we&apos;re acting on an entity.
                x: self.character.x,
                y: self.character.y
            })
        });
    }

    dealAoE(radius, hasTerror) {
        let self = this;

        /**
         * TODO - Find a way to implement special effects without hardcoding them.
         */

        if (!self.world) return;

        let entities = self.world
            .getGrids()
            .getSurroundingEntities(self.character, radius);

        _.each(entities, entity =&gt; {
            let hitData = new Hit(
                Modules.Hits.Damage,
                Formulas.getAoEDamage(self.character, entity)
            ).getData();

            hitData.isAoE = true;
            hitData.hasTerror = hasTerror;

            self.hit(self.character, entity, hitData);
        });
    }

    forceAttack() {
        let self = this;

        if (!self.character.target || !self.inProximity()) return;

        self.stop();
        self.start();

        self.attackCount(2, self.character.target);
        self.hit(self.character, self.character.target, self.queue.getHit());
    }

    attackCount(count, target) {
        let self = this;

        for (let i = 0; i &lt; count; i++) self.attack(target);
    }

    addAttacker(character) {
        let self = this;

        if (self.hasAttacker(character)) return;

        self.attackers[character.instance] = character;
    }

    removeAttacker(character) {
        let self = this;

        if (self.hasAttacker(character))
            delete self.attackers[character.instance];

        if (!self.isAttacked()) self.sendToSpawn();
    }

    sendToSpawn() {
        let self = this;

        if (!self.isMob()) return;

        self.character.return();

        self.world.push(Packets.PushOpcode.Regions, {
            regionId: self.character.region,
            message: new Messages.Movement(Packets.MovementOpcode.Move, {
                id: self.character.instance,
                x: self.character.x,
                y: self.character.y,
                forced: false,
                teleport: false
            })
        });
    }

    hasAttacker(character) {
        let self = this;

        if (!self.isAttacked()) return;

        return character.instance in self.attackers;
    }

    onSameTile() {
        let self = this;

        if (!self.character.target || self.character.type !== &apos;mob&apos;) return;

        return (
            self.character.x === self.character.target.x &amp;&amp;
            self.character.y === self.character.target.y
        );
    }

    isAttacked() {
        return this.attackers &amp;&amp; Object.keys(this.attackers).length &gt; 0;
    }

    getNewPosition() {
        let self = this,
            position = {
                x: self.character.x,
                y: self.character.y
            };

        let random = Utils.randomInt(0, 3);

        if (random === 0) position.x++;
        else if (random === 1) position.y--;
        else if (random === 2) position.x--;
        else if (random === 3) position.y++;

        return position;
    }

    isRetaliating() {
        return (
            this.isPlayer() &amp;&amp;
            !this.character.hasTarget() &amp;&amp;
            this.retaliate &amp;&amp;
            !this.character.moving &amp;&amp;
            new Date().getTime() - this.character.lastMovement &gt; 1500
        );
    }

    inProximity() {
        let self = this;

        if (!self.character.target) return;

        let targetDistance = self.character.getDistance(self.character.target),
            range = self.character.attackRange;

        if (self.character.isRanged()) return targetDistance &lt;= range;

        return self.character.isNonDiagonal(self.character.target);
    }

    getClosestAttacker() {
        let self = this,
            closest = null,
            lowestDistance = 100;

        self.forEachAttacker(attacker =&gt; {
            let distance = self.character.getDistance(attacker);

            if (distance &lt; lowestDistance) closest = attacker;
        });

        return closest;
    }

    setWorld(world) {
        let self = this;

        if (!self.world) self.world = world;
    }

    forget() {
        let self = this;

        self.attackers = {};
        self.character.removeTarget();

        if (self.forgetCallback) self.forgetCallback();
    }

    move(character, x, y) {
        let self = this;

        /**
         * The server and mob types can parse the mob movement
         */

        if (character.type !== &apos;mob&apos;) return;

        character.setPosition(x, y);
    }

    hit(character, target, hitInfo) {
        let self = this,
            time = self.getTime();

        if (time - self.lastHit &lt; self.character.attackRate &amp;&amp; !hitInfo.isAoE)
            return;

        if (character.isRanged() || hitInfo.isRanged) {
            let projectile = self.world.createProjectile(
                [character, target],
                hitInfo
            );

            self.world.push(Packets.PushOpcode.Regions, {
                regionId: character.region,
                message: new Messages.Projectile(
                    Packets.ProjectileOpcode.Create,
                    projectile.getData()
                )
            });
        } else {
            self.world.push(Packets.PushOpcode.Regions, {
                regionId: character.region,
                message: new Messages.Combat(Packets.CombatOpcode.Hit, {
                    attackerId: character.instance,
                    targetId: target.instance,
                    hitInfo: hitInfo
                })
            });

            self.world.handleDamage(character, target, hitInfo.damage);
        }

        if (character.damageCallback) character.damageCallback(target, hitInfo);

        self.lastHit = self.getTime();
    }

    follow(character, target) {
        this.world.push(Packets.PushOpcode.Regions, {
            regionId: character.region,
            message: new Messages.Movement(Packets.MovementOpcode.Follow, {
                attackerId: character.instance,
                targetId: target.instance,
                isRanged: character.isRanged,
                attackRange: character.attackRange
            })
        });
    }

    end() {
        this.world.push(Packets.PushOpcode.Regions, {
            regionId: this.character.region,
            message: new Messages.Combat(Packets.CombatOpcode.Finish, {
                attackerId: this.character.instance,
                targetId: null
            })
        });
    }

    sendFollow() {
        let self = this;

        if (!self.character.hasTarget() || self.character.target.isDead())
            return;

        let ignores = [self.character.instance, self.character.target.instance];

        self.world.push(Packets.PushOpcode.Selectively, {
            message: new Messages.Movement(Packets.MovementOpcode.Follow, {
                attackerId: self.character.instance,
                targetId: self.character.target.instance
            }),
            ignores: ignores
        });
    }

    forEachAttacker(callback) {
        _.each(this.attackers, attacker =&gt; {
            callback(attacker);
        });
    }

    onForget(callback) {
        this.forgetCallback = callback;
    }

    targetOutOfBounds() {
        let self = this;

        if (!self.character.hasTarget() || !self.isMob()) return;

        let spawnPoint = self.character.spawnLocation,
            target = self.character.target;

        return (
            Utils.getDistance(
                spawnPoint[0],
                spawnPoint[1],
                target.x,
                target.y
            ) &gt; self.character.spawnDistance
        );
    }

    getTime() {
        return new Date().getTime();
    }

    colliding(x, y) {
        return this.world.map.isColliding(x, y);
    }

    isPlayer() {
        return this.character.type === &apos;player&apos;;
    }

    isMob() {
        return this.character.type === &apos;mob&apos;;
    }

    isTargetMob() {
        return this.character.target.type === &apos;mob&apos;;
    }

    canAttackAoE(target) {
        return (
            this.isMob() ||
            target.type === &apos;mob&apos; ||
            (this.isPlayer() &amp;&amp;
                target.type === &apos;player&apos; &amp;&amp;
                target.pvp &amp;&amp;
                this.character.pvp)
        );
    }
}

module.exports = Combat;
</code></pre>

</div>

<footer class="footer">
  Generated by <a href="https://esdoc.org">ESDoc<span data-ice="esdocVersion">(1.1.0)</span><img src="./image/esdoc-logo-mini-black.png"></a>
</footer>

<script src="script/search_index.js"></script>
<script src="script/search.js"></script>
<script src="script/pretty-print.js"></script>
<script src="script/inherited-summary.js"></script>
<script src="script/test-summary.js"></script>
<script src="script/inner-link.js"></script>
<script src="script/patch-for-local.js"></script>
</body>
</html>
