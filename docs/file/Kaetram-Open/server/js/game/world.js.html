<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <base data-ice="baseUrl" href="../../../../../">
  <title data-ice="title">Kaetram-Open/server/js/game/world.js | kaetram</title>
  <link type="text/css" rel="stylesheet" href="css/style.css">
  <link type="text/css" rel="stylesheet" href="css/prettify-tomorrow.css">
  <script src="script/prettify/prettify.js"></script>
  <script src="script/manual.js"></script>
<meta name="description" content="Kaetram is an open-source game-engine created to aid those interested in entering the game development realm. The codebase is simple, clean, and intuitive, and is intended to be used as a learning tool. The original idea is based off Little Workshop&apos;s demo game - BrowserQuest. The assets have remained the same, but the code itself has been completely wiped and redone from the ground up.Kaetram is an open-source game-engine created to aid those interested in entering the game development realm. The codebase is simple, clean, and intuitive, and is intended to be used as a learning tool. The original idea is based off Little Workshop&apos;s demo game - BrowserQuest. The assets have remained the same, but the code itself has been completely wiped and redone from the ground up."><meta property="twitter:card" content="summary"><meta property="twitter:title" content="kaetram"><meta property="twitter:description" content="Kaetram is an open-source game-engine created to aid those interested in entering the game development realm. The codebase is simple, clean, and intuitive, and is intended to be used as a learning tool. The original idea is based off Little Workshop&apos;s demo game - BrowserQuest. The assets have remained the same, but the code itself has been completely wiped and redone from the ground up.Kaetram is an open-source game-engine created to aid those interested in entering the game development realm. The codebase is simple, clean, and intuitive, and is intended to be used as a learning tool. The original idea is based off Little Workshop&apos;s demo game - BrowserQuest. The assets have remained the same, but the code itself has been completely wiped and redone from the ground up."></head>
<body class="layout-container" data-ice="rootContainer">

<header>
  <a href="./">Home</a>
  
  <a href="identifiers.html">Reference</a>
  <a href="source.html">Source</a>
  
  <div class="search-box">
  <span>
    <img src="./image/search.png">
    <span class="search-input-edge"></span><input class="search-input"><span class="search-input-edge"></span>
  </span>
    <ul class="search-result"></ul>
  </div>
<a style="position:relative; top:3px;" href="https://github.com/Veradictus/Kaetram-Open"><img width="20px" src="./image/github.png"></a></header>

<nav class="navigation" data-ice="nav"><div>
  <ul>
    
  </ul>
</div>
</nav>

<div class="content" data-ice="content"><h1 data-ice="title">Kaetram-Open/server/js/game/world.js</h1>
<pre class="source-code line-number raw-source-code"><code class="prettyprint linenums" data-ice="content">/* global module */

let config = require(&apos;../../config.json&apos;),
    Player = require(&apos;./entity/character/player/player&apos;),
    Map = require(&apos;../map/map&apos;),
    _ = require(&apos;underscore&apos;),
    Messages = require(&apos;../network/messages&apos;),
    Utils = require(&apos;../util/utils&apos;),
    Mobs = require(&apos;../util/mobs&apos;),
    Mob = require(&apos;./entity/character/mob/mob&apos;),
    NPCs = require(&apos;../util/npcs&apos;),
    NPC = require(&apos;./entity/npc/npc&apos;),
    Items = require(&apos;../util/items&apos;),
    Item = require(&apos;./entity/objects/item&apos;),
    Chest = require(&apos;./entity/objects/chest&apos;),
    Character = require(&apos;./entity/character/character&apos;),
    Projectile = require(&apos;./entity/objects/projectile&apos;),
    Packets = require(&apos;../network/packets&apos;),
    Formulas = require(&apos;../util/formulas&apos;),
    Modules = require(&apos;../util/modules&apos;),
    Shops = require(&apos;../controllers/shops&apos;),
    Region = require(&apos;../region/region&apos;),
    Network = require(&apos;../network/network&apos;);

class World {
    constructor(id, socket, database) {
        let self = this;

        self.id = id;
        self.socket = socket;
        self.database = database;

        self.playerCount = 0;

        self.maxPlayers = config.maxPlayers;
        self.updateTime = config.updateTime;

        self.debug = false;

        self.players = {};
        self.entities = {};
        self.items = {};
        self.chests = {};
        self.mobs = {};
        self.npcs = {};
        self.projectiles = {};

        self.loadedRegions = false;

        self.ready = false;

        self.malformTimeout = null;
    }

    load(onWorldLoad) {
        let self = this;

        log.info(&apos;************ World &apos; + self.id + &apos; ***********&apos;);

        /**
         * The reason maps are loaded per each world is because
         * we can have slight modifications for each world if we want in the
         * future. Using region loading, we can just send the client
         * whatever new map we have created server sided. Cleaner and nicer.
         */

        self.map = new Map(self);
        self.map.isReady(() =&gt; {
            log.info(&apos;The map has been successfully loaded!&apos;);

            self.loaded();

            self.spawnChests();
            self.spawnEntities();

            onWorldLoad();
        });
    }

    loaded() {
        let self = this;
        /**
         * Similar to Kaetram engine here, but it&apos;s loaded upon initialization
         * rather than being called from elsewhere.
         */

        self.shops = new Shops(self);
        self.region = new Region(self);
        self.network = new Network(self);

        self.ready = true;

        self.tick();

        log.info(&apos;********************************&apos;);
    }

    tick() {
        let self = this;

        setInterval(() =&gt; {
            self.network.parsePackets();
            self.region.parseRegions();
        }, 1000 / self.updateTime);
    }

    /** **************************
     * Entity related functions *
     ****************************/

    kill(entity) {
        let self = this;

        entity.applyDamage(entity.hitPoints);

        self.push(Packets.PushOpcode.Regions, [
            {
                regionId: entity.region,
                message: new Messages.Points({
                    id: entity.instance,
                    hitPoints: entity.getHitPoints(),
                    mana: null
                })
            },
            {
                regionId: entity.region,
                message: new Messages.Despawn(entity.instance)
            }
        ]);

        self.handleDeath(entity, true);
    }

    handleDamage(attacker, target, damage) {
        let self = this;

        if (!attacker || !target || isNaN(damage) || target.invincible) return;

        if (target.type === &apos;player&apos; &amp;&amp; target.hitCallback)
            target.hitCallback(attacker, damage);

        // Stop screwing with this - it&apos;s so the target retaliates.

        target.hit(attacker);
        target.applyDamage(damage);

        self.push(Packets.PushOpcode.Regions, {
            regionId: target.region,
            message: new Messages.Points({
                id: target.instance,
                hitPoints: target.getHitPoints(),
                mana: null
            })
        });

        // If target has died...
        if (target.getHitPoints() &lt; 1) {
            if (target.type === &apos;mob&apos;)
                attacker.addExperience(Mobs.getXp(target.id));

            if (attacker.type === &apos;player&apos;) attacker.killCharacter(target);

            target.combat.forEachAttacker(attacker =&gt; {
                attacker.removeTarget();
            });

            self.push(Packets.PushOpcode.Regions, [
                {
                    regionId: target.region,
                    message: new Messages.Combat(Packets.CombatOpcode.Finish, {
                        attackerId: attacker.instance,
                        targetId: target.instance
                    })
                },
                {
                    regionId: target.region,
                    message: new Messages.Despawn(target.instance)
                }
            ]);

            self.handleDeath(target);
        }
    }

    handleDeath(character, ignoreDrops) {
        let self = this;

        if (!character) return;

        if (character.type === &apos;mob&apos;) {
            let deathX = character.x,
                deathY = character.y;

            if (character.deathCallback) character.deathCallback();

            self.removeEntity(character);

            character.dead = true;

            character.destroy();

            character.combat.stop();

            if (!ignoreDrops) {
                let drop = character.getDrop();

                if (drop) self.dropItem(drop.id, drop.count, deathX, deathY);
            }
        } else if (character.type === &apos;player&apos;) character.die();
    }

    createProjectile(info) {
        let self = this,
            attacker = info.shift(),
            target = info.shift();

        if (!attacker || !target) return null;

        let startX = attacker.x,
            startY = attacker.y,
            type = attacker.getProjectile(),
            hit = null,
            projectile = new Projectile(
                type,
                Utils.generateInstance(5, type, startX + startY)
            );

        projectile.setStart(startX, startY);
        projectile.setTarget(target);

        if (attacker.type === &apos;player&apos;) hit = attacker.getHit(target);

        projectile.damage = hit
            ? hit.damage
            : Formulas.getDamage(attacker, target, true);
        projectile.hitType = hit ? hit.type : Modules.Hits.Damage;

        projectile.owner = attacker;

        self.addProjectile(projectile, projectile.owner.region);

        return projectile;
    }

    getEntityByInstance(instance) {
        if (instance in this.entities) return this.entities[instance];
    }

    spawnEntities() {
        let self = this,
            entities = 0;

        _.each(self.map.staticEntities, data =&gt; {
            let key = data.string,
                isMob = !!Mobs.Properties[key],
                isNpc = !!NPCs.Properties[key],
                isItem = !!Items.Data[key],
                info = isMob
                    ? Mobs.Properties[key]
                    : isNpc
                    ? NPCs.Properties[key]
                    : isItem
                    ? Items.getData(key)
                    : null,
                position = self.map.indexToGridPosition(data.tileIndex);

            position.x++;

            if (!info || info === &apos;null&apos;) {
                if (self.debug) {
                    log.info(
                        &apos;Unknown object spawned at: &apos; +
                            position.x +
                            &apos; &apos; +
                            position.y
                    );
                }

                return;
            }

            let instance = Utils.generateInstance(
                isMob ? 2 : isNpc ? 3 : 4,
                info.id + entities,
                position.x + entities,
                position.y
            );

            if (isMob) {
                let mob = new Mob(
                    info.id,
                    instance,
                    position.x,
                    position.y,
                    self
                );

                mob.static = true;

                if (data.roaming) mob.roaming = true;

                if (Mobs.Properties[key].hiddenName)
                    mob.hiddenName = Mobs.Properties[key].hiddenName;

                mob.load();

                mob.onRespawn(() =&gt; {
                    mob.dead = false;

                    mob.refresh();

                    self.addMob(mob);
                });

                self.addMob(mob);
            }

            if (isNpc)
                self.addNPC(new NPC(info.id, instance, position.x, position.y));

            if (isItem) {
                let item = self.createItem(
                    info.id,
                    instance,
                    position.x,
                    position.y
                );
                item.static = true;
                self.addItem(item);
            }

            entities++;
        });

        log.info(&apos;Spawned &apos; + Object.keys(self.entities).length + &apos; entities!&apos;);
    }

    spawnChests() {
        let self = this,
            chests = 0;

        _.each(self.map.chests, info =&gt; {
            self.spawnChest(info.i, info.x, info.y, true);

            chests++;
        });

        log.info(
            &apos;Spawned &apos; + Object.keys(self.chests).length + &apos; static chests&apos;
        );
    }

    spawnMob(id, x, y) {
        let self = this,
            instance = Utils.generateInstance(2, id, x + id, y),
            mob = new Mob(id, instance, x, y);

        if (!Mobs.exists(id)) return;

        self.addMob(mob);

        return mob;
    }

    spawnChest(items, x, y, staticChest) {
        let self = this,
            chestCount = Object.keys(self.chests).length,
            instance = Utils.generateInstance(5, 194, chestCount, x, y),
            chest = new Chest(194, instance, x, y);

        chest.items = items;

        if (staticChest) {
            chest.static = staticChest;

            chest.onRespawn(self.addChest.bind(self, chest));
        }

        chest.onOpen(() =&gt; {
            /**
             * Pretty simple concept, detect when the player opens the chest
             * then remove it and drop an item instead. Give it a 25 second
             * cooldown prior to respawning and voila.
             */

            self.removeChest(chest);

            if (config.debug)
                log.info(`Opening chest at x: ${chest.x}, y: ${chest.y}`);

            self.dropItem(
                Items.stringToId(chest.getItem()),
                1,
                chest.x,
                chest.y
            );
        });

        self.addChest(chest);

        return chest;
    }

    createItem(id, instance, x, y) {
        return new Item(id, instance, x, y);
    }

    dropItem(id, count, x, y) {
        let self = this,
            instance = Utils.generateInstance(
                4,
                id + Object.keys(self.entities).length,
                x,
                y
            ),
            item = self.createItem(id, instance, x, y);

        item.count = count;
        item.dropped = true;

        self.addItem(item);
        item.despawn();

        if (config.debug) {
            log.info(`Item - ${id} has been dropped at x: ${x}, y: ${y}.`);
            log.info(`Item Region - ${item.region}`);
        }

        item.onBlink(() =&gt; {
            self.push(Packets.PushOpcode.Broadcast, {
                message: new Messages.Blink(item.intsance)
            });
        });

        item.onDespawn(() =&gt; {
            self.removeItem(item);
        });
    }

    push(type, info) {
        let self = this;

        if (_.isArray(info)) {
            _.each(info, i =&gt; {
                self.push(type, i);
            });
            return;
        }

        if (!info.message) {
            log.info(&apos;No message found whilst attempting to push.&apos;);
            log.info(info);
            return;
        }

        switch (type) {
            case Packets.PushOpcode.Broadcast:
                self.network.pushBroadcast(info.message);

                break;

            case Packets.PushOpcode.Selectively:
                self.network.pushSelectively(info.message, info.ignores);

                break;

            case Packets.PushOpcode.Player:
                self.network.pushToPlayer(info.player, info.message);

                break;

            case Packets.PushOpcode.Players:
                self.network.pushToPlayers(info.players, info.message);

                break;

            case Packets.PushOpcode.Region:
                self.network.pushToRegion(
                    info.regionId,
                    info.message,
                    info.ignoreId
                );

                break;

            case Packets.PushOpcode.Regions:
                self.network.pushToAdjacentRegions(
                    info.regionId,
                    info.message,
                    info.ignoreId
                );

                break;

            case Packets.PushOpcode.NameArray:
                self.network.pushToNameArray(info.names, info.message);

                break;

            case Packets.PushOpcode.OldRegions:
                self.network.pushToOldRegions(info.player, info.message);

                break;
        }
    }

    addEntity(entity, region) {
        let self = this;

        if (entity.instance in self.entities)
            log.info(&apos;Entity &apos; + entity.instance + &apos; already exists.&apos;);

        self.entities[entity.instance] = entity;

        if (entity.type !== &apos;projectile&apos;) self.region.handle(entity, region);

        if (entity.x &gt; 0 &amp;&amp; entity.y &gt; 0)
            self.getGrids().addToEntityGrid(entity, entity.x, entity.y);

        entity.onSetPosition(() =&gt; {
            self.getGrids().updateEntityPosition(entity);

            if (entity.isMob() &amp;&amp; entity.isOutsideSpawn()) {
                entity.removeTarget();
                entity.combat.forget();
                entity.combat.stop();

                entity.return();

                self.push(Packets.PushOpcode.Broadcast, [
                    {
                        message: new Messages.Combat(
                            Packets.CombatOpcode.Finish,
                            {
                                attackerId: null,
                                targetId: entity.instance
                            }
                        )
                    },
                    {
                        message: new Messages.Movement(
                            Packets.MovementOpcode.Move,
                            {
                                id: entity.instance,
                                x: entity.x,
                                y: entity.y,
                                forced: false,
                                teleport: false
                            }
                        )
                    }
                ]);
            }
        });

        if (entity instanceof Character) {
            entity.getCombat().setWorld(self);

            entity.onStunned(stun =&gt; {
                self.push(Packets.PushOpcode.Regions, {
                    regionId: entity.region,
                    message: new Messages.Movement(
                        Packets.MovementOpcode.Stunned,
                        {
                            id: entity.instance,
                            state: stun
                        }
                    )
                });
            });
        }
    }

    addPlayer(player) {
        let self = this;

        self.addEntity(player);
        self.players[player.instance] = player;

        if (self.populationCallback) self.populationCallback();
    }

    addNPC(npc, region) {
        let self = this;

        self.addEntity(npc, region);
        self.npcs[npc.instance] = npc;
    }

    addMob(mob, region) {
        let self = this;

        if (!Mobs.exists(mob.id)) {
            log.error(&apos;Cannot spawn mob. &apos; + mob.id + &apos; does not exist.&apos;);
            return;
        }

        self.addEntity(mob, region);
        self.mobs[mob.instance] = mob;

        mob.addToChestArea(self.getChestAreas());

        mob.onHit(attacker =&gt; {
            if (mob.isDead() || mob.combat.started) return;

            mob.combat.begin(attacker);
        });
    }

    addItem(item, region) {
        let self = this;

        if (item.static) item.onRespawn(self.addItem.bind(self, item));

        self.addEntity(item, region);
        self.items[item.instance] = item;
    }

    addProjectile(projectile, region) {
        let self = this;

        self.addEntity(projectile, region);
        self.projectiles[projectile.instance] = projectile;
    }

    addChest(chest, region) {
        let self = this;

        self.addEntity(chest, region);
        self.chests[chest.instance] = chest;
    }

    removeEntity(entity) {
        let self = this;

        if (entity.instance in self.entities)
            delete self.entities[entity.instance];

        if (entity.instance in self.mobs) delete self.mobs[entity.instance];

        if (entity.instance in self.items) delete self.items[entity.instance];

        self.getGrids().removeFromEntityGrid(entity, entity.x, entity.y);

        self.region.remove(entity);
    }

    cleanCombat(entity) {
        let self = this;

        _.each(this.entities, oEntity =&gt; {
            if (
                oEntity instanceof Character &amp;&amp;
                oEntity.combat.hasAttacker(entity)
            )
                oEntity.combat.removeAttacker(entity);
        });
    }

    removeItem(item) {
        let self = this;

        self.removeEntity(item);
        self.push(Packets.PushOpcode.Broadcast, {
            message: new Messages.Despawn(item.instance)
        });

        if (item.static) item.respawn();
    }

    removePlayer(player) {
        let self = this;

        self.push(Packets.PushOpcode.Regions, {
            regionId: player.region,
            message: new Messages.Despawn(player.instance)
        });

        if (player.ready) player.save();

        if (self.populationCallback) self.populationCallback();

        self.removeEntity(player);

        self.cleanCombat(player);

        if (player.isGuest) self.database.delete(player);

        delete self.players[player.instance];
        delete self.network.packets[player.instance];
    }

    removeProjectile(projectile) {
        let self = this;

        self.removeEntity(projectile);

        delete self.projectiles[projectile.instance];
    }

    removeChest(chest) {
        let self = this;

        self.removeEntity(chest);
        self.push(Packets.PushOpcode.Broadcast, {
            message: new Messages.Despawn(chest.instance)
        });

        if (chest.static) chest.respawn();
        else delete self.chests[chest.instance];
    }

    playerInWorld(username) {
        let self = this;

        for (let id in self.players) {
            if (self.players.hasOwnProperty(id)) {
                if (
                    self.players[id].username.toLowerCase() ===
                    username.toLowerCase()
                )
                    return true;
            }
        }

        return false;
    }

    getPlayerByName(name) {
        let self = this;

        for (let id in self.players) {
            if (self.players.hasOwnProperty(id)) {
                if (
                    self.players[id].username.toLowerCase() ===
                    name.toLowerCase()
                )
                    return self.players[id];
            }
        }

        return null;
    }

    getPlayerByInstance(instance) {
        let self = this;

        if (instance in self.players) return self.players[instance];

        return null;
    }

    forEachPlayer(callback) {
        _.each(this.players, player =&gt; {
            callback(player);
        });
    }

    getPVPAreas() {
        return this.map.areas.PVP.pvpAreas;
    }

    getMusicAreas() {
        return this.map.areas.Music.musicAreas;
    }

    getChestAreas() {
        return this.map.areas.Chests.chestAreas;
    }

    getOverlayAreas() {
        return this.map.areas.Overlays.overlayAreas;
    }

    getCameraAreas() {
        return this.map.areas.Cameras.cameraAreas;
    }

    getGrids() {
        return this.map.grids;
    }

    getPopulation() {
        return _.size(this.players);
    }

    onPlayerConnection(callback) {
        this.playerConnectCallback = callback;
    }

    onPopulationChange(callback) {
        this.populationCallback = callback;
    }
}

module.exports = World;
</code></pre>

</div>

<footer class="footer">
  Generated by <a href="https://esdoc.org">ESDoc<span data-ice="esdocVersion">(1.1.0)</span><img src="./image/esdoc-logo-mini-black.png"></a>
</footer>

<script src="script/search_index.js"></script>
<script src="script/search.js"></script>
<script src="script/pretty-print.js"></script>
<script src="script/inherited-summary.js"></script>
<script src="script/test-summary.js"></script>
<script src="script/inner-link.js"></script>
<script src="script/patch-for-local.js"></script>
</body>
</html>
