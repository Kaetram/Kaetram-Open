<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <base data-ice="baseUrl" href="../../../../../">
  <title data-ice="title">Kaetram-Open/server/js/region/region.js | kaetram</title>
  <link type="text/css" rel="stylesheet" href="css/style.css">
  <link type="text/css" rel="stylesheet" href="css/prettify-tomorrow.css">
  <script src="script/prettify/prettify.js"></script>
  <script src="script/manual.js"></script>
<meta name="description" content="Kaetram is an open-source game-engine created to aid those interested in entering the game development realm. The codebase is simple, clean, and intuitive, and is intended to be used as a learning tool. The original idea is based off Little Workshop&apos;s demo game - BrowserQuest. The assets have remained the same, but the code itself has been completely wiped and redone from the ground up."><meta property="twitter:card" content="summary"><meta property="twitter:title" content="kaetram"><meta property="twitter:description" content="Kaetram is an open-source game-engine created to aid those interested in entering the game development realm. The codebase is simple, clean, and intuitive, and is intended to be used as a learning tool. The original idea is based off Little Workshop&apos;s demo game - BrowserQuest. The assets have remained the same, but the code itself has been completely wiped and redone from the ground up."></head>
<body class="layout-container" data-ice="rootContainer">

<header>
  <a href="./">Home</a>
  
  <a href="identifiers.html">Reference</a>
  <a href="source.html">Source</a>
  
  <div class="search-box">
  <span>
    <img src="./image/search.png">
    <span class="search-input-edge"></span><input class="search-input"><span class="search-input-edge"></span>
  </span>
    <ul class="search-result"></ul>
  </div>
<a style="position:relative; top:3px;" href="https://github.com/Veradictus/Kaetram-Open"><img width="20px" src="./image/github.png"></a></header>

<nav class="navigation" data-ice="nav"><div>
  <ul>
    
  </ul>
</div>
</nav>

<div class="content" data-ice="content"><h1 data-ice="title">Kaetram-Open/server/js/region/region.js</h1>
<pre class="source-code line-number raw-source-code"><code class="prettyprint linenums" data-ice="content">/* global module */

let _ = require(&apos;underscore&apos;),
    Messages = require(&apos;../network/messages&apos;),
    Packets = require(&apos;../network/packets&apos;),
    Player = require(&apos;../game/entity/character/player/player&apos;),
    fs = require(&apos;fs&apos;),
    ClientMap = require(&apos;../../data/map/world_client.json&apos;),
    config = require(&apos;../../config&apos;),
    map = &apos;server/data/map/world_client.json&apos;;

class Region {
    /**
     * Region Generation.
     * This is used in order to send the client data about the new region
     * it is about to enter. This has to be greatly expanded to generated
     * instanced areas where other entities will not be pushed to surrounding
     * players, even if they share the same coordinates.
     */

    constructor(world) {
        let self = this;

        self.map = world.map;
        self.mapRegions = world.map.regions;

        self.world = world;

        self.regions = {};
        self.loaded = false;

        self.onAdd((entity, regionId) =&gt; {
            if (!entity || !entity.username) return;

            if (config.debug) {
                log.info(
                    &apos;Entity - &apos; +
                        entity.username +
                        &apos; has entered region - &apos; +
                        regionId
                );
            }

            if (entity instanceof Player) self.sendRegion(entity, regionId);
        });

        self.onRemove((entity, oldRegions) =&gt; {
            if (
                !oldRegions ||
                oldRegions.length &lt; 1 ||
                !entity ||
                !entity.username
            )
                return;
        });

        self.onIncoming((entity, regionId) =&gt; {
            if (!entity || !entity.username) return;

            if (config.debug) {
                log.info(
                    &apos;Entity - &apos; +
                        entity.username +
                        &apos; is incoming into region - &apos; +
                        regionId
                );
            }
        });

        fs.watchFile(map, () =&gt; {
            log.info(&apos;Received Map Update -&gt; Sending to Players...&apos;);

            fs.readFile(map, &apos;utf8&apos;, (error, data) =&gt; {
                if (error) throw error;

                ClientMap = JSON.parse(data);

                self.updateRegions();
            });
        });

        self.load();
    }

    load() {
        let self = this;

        self.clientWidth = ClientMap.width;
        self.clientHeight = ClientMap.height;

        self.mapRegions.forEachRegion(regionId =&gt; {
            self.regions[regionId] = {
                entities: {},
                players: [],
                incoming: []
            };
        });

        self.loaded = true;

        log.info(&apos;Finished loading regions!&apos;);
    }

    addEntityToInstance(entity, player) {
        let self = this;

        if (!entity) return;

        self.add(entity, player.region);

        player.updateRegion();
    }

    createInstance(player, regionId) {
        let self = this;

        /**
         * We create an instance at the player&apos;s current surrounding
         * region IDs. These will have to be disposed of whenever we&apos;re done.
         */

        player.instanced = true;

        self.mapRegions.forEachAdjacentRegion(regionId, region =&gt; {
            self.regions[Region.regionIdToInstance(player, region)] = {
                entities: {},
                players: [],
                incoming: []
            };
        });

        self.handle(player, true);
        self.push(player);

        self.world.push(Packets.PushOpcode.OldRegions, {
            player: player,
            message: new Messages.Region(Packets.RegionOpcode.Update, {
                id: player.instance,
                type: &apos;remove&apos;
            })
        });
    }

    deleteInstance(player) {
        let self = this;

        player.instanced = false;

        self.handle(player);
        self.push(player);

        self.mapRegions.forEachAdjacentRegion(player.region, regionId =&gt; {
            let instancedRegion = Region.regionIdToInstance(player, regionId);

            if (instancedRegion in self.regions)
                delete self.regions[instancedRegion];
        });
    }

    parseRegions() {
        let self = this;

        if (!self.loaded) return;

        self.mapRegions.forEachRegion(regionId =&gt; {
            if (self.regions[regionId].incoming.length &lt; 1) return;

            self.sendSpawns(regionId);

            self.regions[regionId].incoming = [];
        });
    }

    updateRegions() {
        let self = this;

        self.world.forEachPlayer(player =&gt; {
            player.regionsLoaded = [];

            self.sendRegion(player, player.region, true);
        });
    }

    sendRegion(player, region, force) {
        let self = this,
            tileData = self.getRegionData(region, player, force),
            dynamicTiles = player.doors.getAllTiles();

        // Send dynamic tiles alongside the region
        for (let i = 0; i &lt; tileData.length; i++) {
            let primaryTile = tileData[i],
                index = dynamicTiles.indexes.indexOf(primaryTile.index);

            if (index &gt; -1) {
                tileData[i].data = dynamicTiles.data[index];
                tileData[i].isCollision = dynamicTiles.collisions[index];
            }
        }

        // Send dynamic tiles independently
        if (tileData.length &lt; 1) {
            for (let i = 0; i &lt; dynamicTiles.indexes.length; i++) {
                tileData[i] = {};

                tileData[i].index = dynamicTiles.indexes[i];
                tileData[i].data = dynamicTiles.data[i];
                tileData[i].isCollision = dynamicTiles.collisions[i];
            }
        }

        // No need to send empty data...
        if (tileData.length &gt; 0) {
            player.send(
                new Messages.Region(
                    Packets.RegionOpcode.Render,
                    tileData,
                    force
                )
            );
        }
    }

    sendSpawns(regionId) {
        let self = this;

        if (!regionId) return;

        _.each(self.regions[regionId].incoming, entity =&gt; {
            if (!entity || !entity.instance || entity.instanced) return;

            self.world.push(Packets.PushOpcode.Regions, {
                regionId: regionId,
                message: new Messages.Spawn(entity),
                ignoreId: entity.isPlayer() ? entity.instance : null
            });
        });
    }

    add(entity, regionId) {
        let self = this,
            newRegions = [];

        if (entity &amp;&amp; regionId &amp;&amp; regionId in self.regions) {
            self.mapRegions.forEachAdjacentRegion(regionId, id =&gt; {
                if (entity.instanced)
                    id = Region.regionIdToInstance(entity, id);

                let region = self.regions[id];

                if (region &amp;&amp; region.entities) {
                    region.entities[entity.instance] = entity;
                    newRegions.push(id);
                }
            });

            entity.region = regionId;

            if (entity instanceof Player)
                self.regions[regionId].players.push(entity.instance);
        }

        if (self.addCallback) self.addCallback(entity, regionId);

        return newRegions;
    }

    remove(entity) {
        let self = this,
            oldRegions = [];

        if (entity &amp;&amp; entity.region) {
            let region = self.regions[entity.region];

            if (entity instanceof Player) {
                region.players = _.reject(region.players, id =&gt; {
                    return id === entity.instance;
                });
            }

            self.mapRegions.forEachAdjacentRegion(entity.region, id =&gt; {
                if (
                    self.regions[id] &amp;&amp;
                    entity.instance in self.regions[id].entities
                ) {
                    delete self.regions[id].entities[entity.instance];
                    oldRegions.push(id);
                }
            });

            entity.region = null;
        }

        if (self.removeCallback) self.removeCallback(entity, oldRegions);

        return oldRegions;
    }

    incoming(entity, regionId) {
        let self = this;

        if (!entity || !regionId) return;

        let region = self.regions[regionId];

        if (region &amp;&amp; !_.include(region.entities, entity.instance))
            region.incoming.push(entity);

        if (self.incomingCallback) self.incomingCallback(entity, regionId);
    }

    handle(entity, region) {
        let self = this,
            regionsChanged = false;

        if (!entity) return regionsChanged;

        let regionId =
            region || self.mapRegions.regionIdFromPosition(entity.x, entity.y);

        if (entity.instanced)
            regionId = Region.regionIdToInstance(entity, regionId);

        if (!entity.region || (entity.region &amp;&amp; entity.region !== regionId)) {
            regionsChanged = true;

            self.incoming(entity, regionId);

            let oldRegions = self.remove(entity),
                newRegions = self.add(entity, regionId);

            if (_.size(oldRegions) &gt; 0)
                entity.recentRegions = _.difference(oldRegions, newRegions);
        }

        return regionsChanged;
    }

    push(player) {
        let self = this,
            entities;

        if (!player || !(player.region in self.regions)) return;

        entities = _.keys(self.regions[player.region].entities);

        entities = _.reject(entities, instance =&gt; {
            return instance === player.instance; // TODO //|| player.isInvisible(instance);
        });

        entities = _.map(entities, instance =&gt; {
            return parseInt(instance);
        });

        player.send(new Messages.List(entities));
    }

    changeTileAt(player, newTile, x, y) {
        let self = this,
            index = self.gridPositionToIndex(x, y);

        player.send(Region.getModify(index, newTile));
    }

    changeGlobalTile(newTile, x, y) {
        let self = this,
            index = self.gridPositionToIndex(x, y);

        ClientMap.data[index] = newTile;

        self.world.push(Packets.PushOpcode.Broadcast, {
            message: Region.getModify(index, newTile)
        });
    }

    getRegionData(region, player, force) {
        let self = this,
            data = [];

        if (!player) return data;

        self.mapRegions.forEachAdjacentRegion(
            region,
            regionId =&gt; {
                if (!player.hasLoadedRegion(regionId) || force) {
                    player.loadRegion(regionId);

                    let bounds = self.getRegionBounds(regionId);

                    for (
                        let i = 0, y = bounds.startY;
                        y &lt;= bounds.endY;
                        y++, i++
                    ) {
                        for (let x = bounds.startX; x &lt; bounds.endX; x++) {
                            let index = self.gridPositionToIndex(x - 1, y),
                                tileData = ClientMap.data[index],
                                isCollision =
                                    ClientMap.collisions.indexOf(index) &gt; -1 ||
                                    !tileData;

                            data.push({
                                index: index,
                                data: tileData,
                                isCollision: isCollision
                            });
                        }
                    }
                }
            },
            2
        );

        return data;
    }

    getRegionBounds(regionId) {
        let self = this,
            regionCoordinates = self.mapRegions.regionIdToCoordinates(regionId);

        return {
            startX: regionCoordinates.x,
            startY: regionCoordinates.y,
            endX: regionCoordinates.x + self.mapRegions.zoneWidth,
            endY: regionCoordinates.y + self.mapRegions.zoneHeight
        };
    }

    static getModify(index, newTile) {
        return new Messages.Region(Packets.RegionOpcode.Modify, {
            index: index,
            newTile: newTile
        });
    }

    static instanceToRegionId(instancedRegionId) {
        let region = instancedRegionId.split(&apos;-&apos;);

        return region[0] + &apos;-&apos; + region[1];
    }

    static regionIdToInstance(player, regionId) {
        return regionId + &apos;-&apos; + player.instance;
    }

    gridPositionToIndex(x, y) {
        return y * this.clientWidth + x + 1;
    }

    onAdd(callback) {
        this.addCallback = callback;
    }

    onRemove(callback) {
        this.removeCallback = callback;
    }

    onIncoming(callback) {
        this.incomingCallback = callback;
    }
}

module.exports = Region;
</code></pre>

</div>

<footer class="footer">
  Generated by <a href="https://esdoc.org">ESDoc<span data-ice="esdocVersion">(1.1.0)</span><img src="./image/esdoc-logo-mini-black.png"></a>
</footer>

<script src="script/search_index.js"></script>
<script src="script/search.js"></script>
<script src="script/pretty-print.js"></script>
<script src="script/inherited-summary.js"></script>
<script src="script/test-summary.js"></script>
<script src="script/inner-link.js"></script>
<script src="script/patch-for-local.js"></script>
</body>
</html>
